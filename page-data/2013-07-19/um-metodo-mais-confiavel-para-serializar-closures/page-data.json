{"componentChunkName":"component---src-templates-post-js","path":"/2013-07-19/um-metodo-mais-confiavel-para-serializar-closures/","result":{"data":{"mdx":{"body":"function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsx mdx */\nvar _frontmatter = {\n  \"title\": \"Um método mais confiável para serializar closures\",\n  \"date\": \"2013-07-19T00:34:33.000Z\",\n  \"published\": true\n};\n\nvar makeShortcode = function makeShortcode(name) {\n  return function MDXDefaultShortcode(props) {\n    console.warn(\"Component \" + name + \" was not imported, exported, or provided by MDXProvider as global scope\");\n    return mdx(\"div\", props);\n  };\n};\n\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, [\"components\"]);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-php\"\n  }), \"<?php\\n/**\\n* Serializes a closure as string\\n* @param \\\\Closure $closure\\n* @return string\\n*/\\nfunction serializeClosure(\\\\Closure $closure) {\\n$ref = new ReflectionFunction($closure);\\n$tokens = token_get_all(file_get_contents($ref->getFileName()));\\n\\n$tokensCount = count($tokens);\\n$start = false;\\n$end = $tokensCount;\\n\\nfor ( $i = 0; $i < $tokensCount; ++$i ) {\\n  if ( is_array($tokens[$i]) && $tokens[$i][0] === T_FUNCTION && $tokens[$i][2] == $ref->getStartLine() ) {\\n    $start = $i;\\n    break;\\n  }\\n}\\n\\nfor ( $i = $start; $i < $tokensCount; ++$i ) {\\n  if ( is_array($tokens[$i]) && $tokens[$i][2] > $ref->getEndLine() ) {\\n    $end = $i - 1;\\n    break;\\n  }\\n}\\n\\n$tokens = array_slice($tokens, $start, $end);\\n\\n$replaceToken = function($a) { return is_array($a) ? $a[1] : $a; };\\n\\nwhile ( count($tokens) > 0 && $tokens[0][0] === T_FUNCTION ) {\\n\\n  if ( !getNesting($parameters, $tokens, '(', ')') ) // does not have parameters\\n    break;\\n\\n  if ( !getNesting($body, $tokens, '{', '}', $parameters['end']) ) // does not have body\\n    break;\\n\\n  if ( ($use_idx = findToken($tokens, T_USE, $parameters['end'] + 2, $body['start'] - 2)) !== false )\\n    getNesting($use, $tokens, '(', ')', $use_idx);\\n\\n  if ( findToken($tokens, T_STRING, 0, $parameters['start']) === false ) { // is anonymous function\\n    while ( getNesting($tmp, $body['tokens'], T_STATIC, ';') ) {\\n      $tmp['start']--;\\n      $tmp['end']++;\\n      array_splice($body['tokens'], $tmp['start'], $tmp['end']);\\n    }\\n\\n    if ( !isset($use) )\\n      $use = array();\\n\\n    $closure = compact('parameters', 'use', 'body');\\n\\n    $variables = $ref->getStaticVariables();\\n\\n    $source = \\\"return function(\\\" . implode('', array_map($replaceToken, $closure['parameters']['tokens'])) .  \\\") \\\";\\n    if ( !empty($closure['use']['tokens']) ) {\\n      $useParams = array_map('trim', explode(',', implode('', array_map($replaceToken, $closure['use']['tokens']))));\\n\\n      foreach ( $useParams as $param ) {\\n        if ( $param[0] == '$')\\n          $source = \\\"$param = \\\" . var_export($variables[substr($param, 1)], true) . \\\";\\\\n$source\\\";\\n      }\\n\\n      $source .= \\\"use(\\\" . implode(', ', $useParams) .  \\\") \\\";\\n    }\\n\\n    $source .= \\\"{\\\" .  implode('', array_map($replaceToken, $closure['body']['tokens'])) . \\\"};\\\";\\n\\n    $test = function($ref) use($source) {\\n      $newClosure = eval($source);\\n      $newRef = new ReflectionFunction($newClosure);\\n\\n      return ( array_map(function($a) { return $a->getName(); }, $newRef->getParameters()) == array_map(function($a) { return $a->getName(); }, $newRef->getParameters()) );\\n    };\\n\\n    if ( $test($ref) )\\n      return $source;\\n  }\\n\\n  $function_idx = findToken($tokens, T_FUNCTION, $body['end'] + 2);\\n\\n  $tokens = $function_idx === false ? array() : array_slice($tokens, $function_idx);\\n}\\n\\nreturn null;\\n}\\n\\nfunction findToken(array $tokens, $needle, $start = 0, $end = PHP_INT_MAX)\\n{\\n$idx = false;\\nfor ( $i = $start, $end = min($end, count($tokens)); $i < $end; ++$i ) {\\n  if ( (is_int($needle) && is_array($tokens[$i]) && $tokens[$i][0] === $needle) ||\\n    is_string($needle) && is_string($tokens[$i]) && $tokens[$i] === $needle ) {\\n    $idx = $i;\\n    break;\\n  }\\n}\\n\\nreturn $idx;\\n}\\n\\nfunction getNesting(&$matches, array $tokens, $begin = '{', $end = '}', $offset = 0)\\n{\\n$level = 0;\\n$start = false;\\n\\nfor ( $i = $offset, $count = count($tokens); $i < $count; ++$i ) {\\n  if ( is_array($tokens[$i]) ? ($tokens[$i][0] === $begin) : ($tokens[$i] === $begin) ) {\\n    ++$level;\\n    if ( $start === false )\\n      $start = $i + 1;\\n  }\\n  elseif ( is_array($tokens[$i]) ? ($tokens[$i][0] === $end) : ($tokens[$i] === $end) ) {\\n    if ( $start === false )\\n      break;\\n\\n    if ( --$level == 0 ) {\\n      $matches = array(\\n        'tokens' => array_slice($tokens, $start, $i - $start),\\n        'start' => $start,\\n        'end' => $i - 1\\n      );\\n      return true;\\n    }\\n  }\\n}\\n\\n$matches = null;\\nreturn false;\\n}\\n\")));\n}\n;\nMDXContent.isMDXComponent = true;","frontmatter":{"title":"Um método mais confiável para serializar closures","date":"2013-07-19T00:34:33.000Z","formattedDate":"19 de julho de 2013 às 00:34"},"wordCount":{"words":null}}},"pageContext":{"slug":"/2013-07-19/um-metodo-mais-confiavel-para-serializar-closures/","next":{"slug":"/2013-05-06/acesso-facil-a-classe-respect-validation-validator/","title":"Acesso fácil à classe `\\Respect\\Validation\\Validator`"}}}}