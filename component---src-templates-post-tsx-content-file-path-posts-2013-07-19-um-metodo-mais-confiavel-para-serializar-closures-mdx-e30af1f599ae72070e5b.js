"use strict";(self.webpackChunk_tassoevan_tassoevan_github_io=self.webpackChunk_tassoevan_tassoevan_github_io||[]).push([[845],{6140:function(e,n,t){t.r(n),t.d(n,{default:function(){return f}});var r=t(8453),a=t(6540);function s(e){const n=Object.assign({pre:"pre",code:"code"},(0,r.R)(),e.components);return a.createElement(n.pre,null,a.createElement(n.code,{className:"language-php"},"<?php\n/**\n* Serializes a closure as string\n* @param \\Closure $closure\n* @return string\n*/\nfunction serializeClosure(\\Closure $closure) {\n$ref = new ReflectionFunction($closure);\n$tokens = token_get_all(file_get_contents($ref->getFileName()));\n\n$tokensCount = count($tokens);\n$start = false;\n$end = $tokensCount;\n\nfor ( $i = 0; $i < $tokensCount; ++$i ) {\n  if ( is_array($tokens[$i]) && $tokens[$i][0] === T_FUNCTION && $tokens[$i][2] == $ref->getStartLine() ) {\n    $start = $i;\n    break;\n  }\n}\n\nfor ( $i = $start; $i < $tokensCount; ++$i ) {\n  if ( is_array($tokens[$i]) && $tokens[$i][2] > $ref->getEndLine() ) {\n    $end = $i - 1;\n    break;\n  }\n}\n\n$tokens = array_slice($tokens, $start, $end);\n\n$replaceToken = function($a) { return is_array($a) ? $a[1] : $a; };\n\nwhile ( count($tokens) > 0 && $tokens[0][0] === T_FUNCTION ) {\n\n  if ( !getNesting($parameters, $tokens, '(', ')') ) // does not have parameters\n    break;\n\n  if ( !getNesting($body, $tokens, '{', '}', $parameters['end']) ) // does not have body\n    break;\n\n  if ( ($use_idx = findToken($tokens, T_USE, $parameters['end'] + 2, $body['start'] - 2)) !== false )\n    getNesting($use, $tokens, '(', ')', $use_idx);\n\n  if ( findToken($tokens, T_STRING, 0, $parameters['start']) === false ) { // is anonymous function\n    while ( getNesting($tmp, $body['tokens'], T_STATIC, ';') ) {\n      $tmp['start']--;\n      $tmp['end']++;\n      array_splice($body['tokens'], $tmp['start'], $tmp['end']);\n    }\n\n    if ( !isset($use) )\n      $use = array();\n\n    $closure = compact('parameters', 'use', 'body');\n\n    $variables = $ref->getStaticVariables();\n\n    $source = \"return function(\" . implode('', array_map($replaceToken, $closure['parameters']['tokens'])) .  \") \";\n    if ( !empty($closure['use']['tokens']) ) {\n      $useParams = array_map('trim', explode(',', implode('', array_map($replaceToken, $closure['use']['tokens']))));\n\n      foreach ( $useParams as $param ) {\n        if ( $param[0] == '$')\n          $source = \"$param = \" . var_export($variables[substr($param, 1)], true) . \";\\n$source\";\n      }\n\n      $source .= \"use(\" . implode(', ', $useParams) .  \") \";\n    }\n\n    $source .= \"{\" .  implode('', array_map($replaceToken, $closure['body']['tokens'])) . \"};\";\n\n    $test = function($ref) use($source) {\n      $newClosure = eval($source);\n      $newRef = new ReflectionFunction($newClosure);\n\n      return ( array_map(function($a) { return $a->getName(); }, $newRef->getParameters()) == array_map(function($a) { return $a->getName(); }, $newRef->getParameters()) );\n    };\n\n    if ( $test($ref) )\n      return $source;\n  }\n\n  $function_idx = findToken($tokens, T_FUNCTION, $body['end'] + 2);\n\n  $tokens = $function_idx === false ? array() : array_slice($tokens, $function_idx);\n}\n\nreturn null;\n}\n\nfunction findToken(array $tokens, $needle, $start = 0, $end = PHP_INT_MAX)\n{\n$idx = false;\nfor ( $i = $start, $end = min($end, count($tokens)); $i < $end; ++$i ) {\n  if ( (is_int($needle) && is_array($tokens[$i]) && $tokens[$i][0] === $needle) ||\n    is_string($needle) && is_string($tokens[$i]) && $tokens[$i] === $needle ) {\n    $idx = $i;\n    break;\n  }\n}\n\nreturn $idx;\n}\n\nfunction getNesting(&$matches, array $tokens, $begin = '{', $end = '}', $offset = 0)\n{\n$level = 0;\n$start = false;\n\nfor ( $i = $offset, $count = count($tokens); $i < $count; ++$i ) {\n  if ( is_array($tokens[$i]) ? ($tokens[$i][0] === $begin) : ($tokens[$i] === $begin) ) {\n    ++$level;\n    if ( $start === false )\n      $start = $i + 1;\n  }\n  elseif ( is_array($tokens[$i]) ? ($tokens[$i][0] === $end) : ($tokens[$i] === $end) ) {\n    if ( $start === false )\n      break;\n\n    if ( --$level == 0 ) {\n      $matches = array(\n        'tokens' => array_slice($tokens, $start, $i - $start),\n        'start' => $start,\n        'end' => $i - 1\n      );\n      return true;\n    }\n  }\n}\n\n$matches = null;\nreturn false;\n}\n"))}var $=function(e){void 0===e&&(e={});const{wrapper:n}=Object.assign({},(0,r.R)(),e.components);return n?a.createElement(n,e,a.createElement(s,e)):s(e)},o=t(4387),i=t(6008),u=t(9031),l=t(4615);function c(e){let{pageContext:n,data:t,children:r}=e;const{frontmatter:{title:s,date:$},slug:c,next:f}=n,{excerpt:m,timeToRead:d}=t.mdx;return a.createElement(a.Fragment,null,a.createElement(o.A,{title:s,description:m}),a.createElement(i.A,null,a.createElement(u.A,null),a.createElement(l.A,{slug:c,title:s,date:new Date(Date.parse($)),timeToRead:Math.ceil(d),next:f},r)))}function f(e){return a.createElement(c,e,a.createElement($,e))}},9031:function(e,n,t){var r=t(6540),a=t(7581),s=t(8864),$=t(4017);const o=a.default.nav.withConfig({displayName:"NavBar__StyledNavBar",componentId:"sc-yc90xv-0"})(["h1{font-size:1em;font-weight:normal;margin:0;}"]);n.A=function(){const{title:e,description:n}=(0,s.Q)();return r.createElement(o,null,r.createElement("h1",null,r.createElement($.A,{href:"/",title:n},e)))}},8453:function(e,n,t){t.d(n,{R:function(){return $}});var r=t(6540);const a={},s=r.createContext(a);function $(e){const n=r.useContext(s);return r.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}}}]);
//# sourceMappingURL=component---src-templates-post-tsx-content-file-path-posts-2013-07-19-um-metodo-mais-confiavel-para-serializar-closures-mdx-e30af1f599ae72070e5b.js.map