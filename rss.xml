<?xml version="1.0" encoding="UTF-8"?><rss xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:atom="http://www.w3.org/2005/Atom" version="2.0"><channel><title><![CDATA[Tasso & As Vozes]]></title><description><![CDATA[Um lugar calmo e tranquilo onde dialogo com as vozes que habitam a minha cabeça]]></description><link>http://github.com/dylang/node-rss</link><generator>GatsbyJS</generator><lastBuildDate>Sun, 24 May 2020 16:41:54 GMT</lastBuildDate><item><title><![CDATA[Notas sobre "The Great CoffeeScript to Typescript Migration of 2017"]]></title><description><![CDATA[Fonte:  https://dropbox.tech/frontend/the-great-coffeescript-to-typescript-migration-of-2017 Pré-história: adoção de CoffeeScript Em 2012, o…]]></description><link>/2020-05-24/notas-sobre-the-great-coffeescript-to-typescript-migration-of-2017/</link><guid isPermaLink="false">/2020-05-24/notas-sobre-the-great-coffeescript-to-typescript-migration-of-2017/</guid><pubDate>Sat, 23 May 2020 22:01:01 GMT</pubDate><content:encoded>&lt;p&gt;Fonte: &lt;a href=&quot;https://dropbox.tech/frontend/the-great-coffeescript-to-typescript-migration-of-2017&quot;&gt;https://dropbox.tech/frontend/the-great-coffeescript-to-typescript-migration-of-2017&lt;/a&gt;&lt;/p&gt;&lt;h2&gt;Pré-história: adoção de CoffeeScript&lt;/h2&gt;&lt;ul&gt;&lt;li&gt;Em 2012, o Dropbox era uma startup com 150 funcionários.&lt;/li&gt;&lt;li&gt;ES5 e jQuery dominavam o desenvolvimento JavaScript.&lt;/li&gt;&lt;li&gt;A codebase consistia de cerca de 100 mil linhas de JavaScript empacotada por simples concatenação de arquivos.&lt;/li&gt;&lt;li&gt;Dois engenheiros migraram tudo para CoffeeScript em uma semana.&lt;/li&gt;&lt;li&gt;Em 2013, adotaram o sistema de módulos RequireJS (AMD) já que CommonJS era restrita a Node e, portanto, não projetada para uso no browser.&lt;/li&gt;&lt;/ul&gt;&lt;h2&gt;Rumores de uma mudança de linguagem&lt;/h2&gt;&lt;ul&gt;&lt;li&gt;Ao final de 2015, ES6 já tinha mais funcionalidades que CoffeeScript.&lt;/li&gt;&lt;li&gt;Alguns times começaram a adotar ES6 em projetos isolados.&lt;/li&gt;&lt;li&gt;A codebase era difícil de manter pois as técnicas de codificação defensiva eram insuficientes e prejudicavam a legibilidade do código.&lt;/li&gt;&lt;li&gt;Por CoffeeScript ser menos estrita que Python no uso de whitespaces, alguns engenheiros verificavam manualmente o código JavaScript gerado; é citado um bug sério no outono de 2013 causado por um espaço em branco mal-posicionado.&lt;/li&gt;&lt;li&gt;Uma pesquisa interna em novembro de 2015 verificou que 62% dos desenvolvedores gostariam de mudar a linguagem utilizada.&lt;/li&gt;&lt;li&gt;Problemas com CoffeeScript apontados:&lt;ul&gt;&lt;li&gt;Falta de delimitadores&lt;/li&gt;&lt;li&gt;&lt;em&gt;Syntactic sugar&lt;/em&gt; muito opinativo&lt;/li&gt;&lt;li&gt;Falta de suporte da comunidade&lt;/li&gt;&lt;li&gt;Leitura difícil pois a sintaxe é muito densa&lt;/li&gt;&lt;li&gt;Sujeita a erros por causa de ambiguidades sintáticas&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;&lt;li&gt;O ferramental de TypeScript parecia melhor que vanilla ES6 + Flow no final de 2015.&lt;/li&gt;&lt;li&gt;No primeiro semestre de 2016, um engenheiro integrou Babel e TypeScript.&lt;/li&gt;&lt;li&gt;Tanto o time quanto a codebase (330 mil linhas) haviam crescido significativamente para uma migração indolor.&lt;/li&gt;&lt;/ul&gt;&lt;h2&gt;Um plano de migração otimista&lt;/h2&gt;&lt;ul&gt;&lt;li&gt;Foram estabelecidas cinco &lt;em&gt;milestones&lt;/em&gt; a serem cumpridas até julho de 2017:
M1. Suporte básico a TypeScript com interoperabilidade com CoffeeScript e ferramentas de i18n, lint e testes;
M2. Documentar boas práticas e guias de migração e migrar as principais bibliotecas e módulos para TypeScript ser a linguagem padrão de desenvolvimento;
M3. Consolidar a &lt;em&gt;milestone&lt;/em&gt; anterior migrando o restante de módulos e bibliotecas;
M4. Migrar os arquivos mais modificados ao longo do tempo no projeto;
M5. Remover o compilador de CoffeeScript.&lt;/li&gt;&lt;li&gt;M1, M2 e M3 foram executadas no segundo semestre de 2016.&lt;/li&gt;&lt;li&gt;M4 e M5 foram mais problemáticas; esperava-se que o código ficaria a cargo dos times que o desenvolveram originalmente.&lt;/li&gt;&lt;li&gt;20% do time de produto foi alocado para trabalhar nas &amp;quot;fundações&amp;quot; da codebase.&lt;/li&gt;&lt;/ul&gt;&lt;h2&gt;Interoperabilidade de CoffeeScript/TypeScript&lt;/h2&gt;&lt;ul&gt;&lt;li&gt;Para cada arquivo de CoffeeScript (&lt;code&gt;*.coffee&lt;/code&gt;), foi criado um arquivo de declarações (&lt;code&gt;*.d.ts&lt;/code&gt;) exportando os módulos como &lt;code&gt;any&lt;/code&gt;.&lt;/li&gt;&lt;li&gt;Módulos em TS com &lt;code&gt;export default value;&lt;/code&gt; eram importados nos módulos AMD como objetos do tipo &lt;code&gt;{ default: value }&lt;/code&gt;; named exports foram migrados com poucos problemas.&lt;/li&gt;&lt;li&gt;Em módulos cujos exports eram dinamicamente determinados, exportou-se todos os identificadores possíveis mas com valores &lt;code&gt;undefined&lt;/code&gt; dinamicamente determinados.&lt;/li&gt;&lt;/ul&gt;&lt;h2&gt;Banindo novos arquivos em CoffeeScript&lt;/h2&gt;&lt;ul&gt;&lt;li&gt;Foi criado um teste automático para barrar a adição de novos arquivos.&lt;/li&gt;&lt;li&gt;Este teste quebrou quando uma migração paralela para &lt;a href=&quot;https://bazel.build/&quot;&gt;Bazel&lt;/a&gt; como sistema de build foi executada, pois a lista de arquivos &lt;code&gt;*.coffee&lt;/code&gt; estava vazia.&lt;/li&gt;&lt;li&gt;Como aprendizado, testes passaram a fazer asserções em suposições (neste caso, de que a lista nunca seria vazia).&lt;/li&gt;&lt;li&gt;A redução da &lt;em&gt;whitelist&lt;/em&gt; de arquivos permitidos gerava pequenos atrasos no code review.&lt;/li&gt;&lt;/ul&gt;&lt;h2&gt;Experiência inicial: não perdemos o &lt;em&gt;syntactic sugar&lt;/em&gt; do CoffeeScript&lt;/h2&gt;&lt;ul&gt;&lt;li&gt;A perda de &lt;em&gt;optional chaining&lt;/em&gt; e &lt;em&gt;nullish coalescing&lt;/em&gt; foi compensada com a adição de tipagem.&lt;/li&gt;&lt;/ul&gt;&lt;h2&gt;Prioridades concorrentes&lt;/h2&gt;&lt;ul&gt;&lt;li&gt;No final de 2016, foi criado um time para redesign e reescrita do website em React (&amp;quot;Maestro&amp;quot;).&lt;/li&gt;&lt;li&gt;O time do Maestro não conseguiu cumprir o prazo do primeiro trimestre, entregando ao término do segundo o projeto completo em React e TypeScript.&lt;/li&gt;&lt;li&gt;A lista de arquivos que deveria ser eliminada na M4 estagnou em 100 arquivos, mas na prática ainda haviam 2000 arquivos em CoffeeScript com manutenção constante.&lt;/li&gt;&lt;/ul&gt;&lt;h2&gt;Adiando a M5&lt;/h2&gt;&lt;ul&gt;&lt;li&gt;Interpretou-se erroneamente que os scripts restantes deveriam ser substituídos pelos arquivos compilados, causando problemas com lint e i18n.&lt;/li&gt;&lt;li&gt;Não ficou claro que o objetivo da M5 era reduzir o custo (já pago) de manter o ferramental de CoffeeScript e TypeScript.&lt;/li&gt;&lt;li&gt;A migração perdeu seu ETA.&lt;/li&gt;&lt;li&gt;A estimativa inicial da migração era de 1000 linhas por dia demandando um ano de trabalho de um único engenheiro; na prática, 100 linhas por dia eram convertidas, significando um tempo de 10 anos ou o trabalho de 10 engenheiros em um ano.&lt;/li&gt;&lt;li&gt;Não havia clareza sobre o que era o trabalho &amp;quot;fundamental&amp;quot; que demandaria 20% do time: se infraestrutura ou pagamento de dívida técnica.&lt;/li&gt;&lt;li&gt;Uma migração de sistemas em produção para uma nova distribuição do Ubuntu tomou boa parte da mão-de-obra de infraestrutura.&lt;/li&gt;&lt;/ul&gt;&lt;h2&gt;Um novo plano com &lt;code&gt;decaffeinate&lt;/code&gt;&lt;/h2&gt;&lt;ul&gt;&lt;li&gt;Em janeiro de 2017, foi sugerido o uso de &lt;code&gt;decaffeinate&lt;/code&gt; para as conversões.&lt;/li&gt;&lt;li&gt;Uma função de ordenação com i18n não-testada quebrou completamente uma página no browser Safari.&lt;/li&gt;&lt;li&gt;A longa lista de bugs semelhantes no &lt;code&gt;decaffeinate&lt;/code&gt; obrigou se adotar uma conversão mista (manual e automática) que eventualmente ocasiona erros a nível de semântica do código.&lt;/li&gt;&lt;li&gt;Seis meses depois, &lt;code&gt;decaffeinate&lt;/code&gt; parecia suficientemente maduro em comparação à conversão manual.&lt;/li&gt;&lt;li&gt;O time entrou em acordo: TypeScript apenas com o tipo &lt;code&gt;any&lt;/code&gt; era preferível a CoffeeScript não-tipado e habilitaria os times a introduzirem tipos no seu próprio ritmo.&lt;/li&gt;&lt;/ul&gt;&lt;h2&gt;Um plano em duas fases&lt;/h2&gt;&lt;ul&gt;&lt;li&gt;A pipeline de migração de código consistia de múltiplas etapas:&lt;ol&gt;&lt;li&gt;Conversão para JavaScript ES6;&lt;/li&gt;&lt;li&gt;Transformações com &lt;code&gt;codemod&lt;/code&gt;, especialmente de funções com binding para &lt;em&gt;arrow functions&lt;/em&gt;;&lt;/li&gt;&lt;li&gt;Transformação da API legada de React para JSX;&lt;/li&gt;&lt;li&gt;Conversão de AMD para módulos ES (especial cuidado com exports);&lt;/li&gt;&lt;li&gt;Anotação de parâmetros de função com &lt;code&gt;any&lt;/code&gt;;&lt;/li&gt;&lt;li&gt;Adição de declaração de membros de classes;&lt;/li&gt;&lt;li&gt;Anotação de componentes com tipos específicos de React;&lt;/li&gt;&lt;li&gt;Adição de comentário explicado como olhar o código CoffeeScript original através do &lt;code&gt;git&lt;/code&gt;;&lt;/li&gt;&lt;/ol&gt;&lt;/li&gt;&lt;li&gt;A etapa final de correção dos tipos envolveu escrever scripts para interpretar os erros vindos do &lt;em&gt;type checking&lt;/em&gt; e aplicar as correções automaticamente.&lt;/li&gt;&lt;/ul&gt;&lt;h2&gt;Mantendo o foco&lt;/h2&gt;&lt;ul&gt;&lt;li&gt;O compromisso de manter uma ferramenta suficientemente boa tornou trivial resolver manualmente problemas como variáveis mortas.&lt;/li&gt;&lt;li&gt;Agrupar a quantidade de erros do &lt;code&gt;tsc&lt;/code&gt; por código de erro gerou uma métrica para a migração e confiança de que estavam na direção correta.&lt;/li&gt;&lt;li&gt;A taxa de erros por arquivo ficou entre 0,5 e 1.&lt;/li&gt;&lt;/ul&gt;&lt;h2&gt;Ganhando confiança nas suas ferramentas&lt;/h2&gt;&lt;ul&gt;&lt;li&gt;Bugs pré-existentes eram capturados rodando testes antes e após as conversões.&lt;/li&gt;&lt;li&gt;Se um erro ocorria em muitos lugares, uma asserção era adicionada à pipeline de migração em vez de realizar correção manual.&lt;/li&gt;&lt;li&gt;Um bug notável destes é relacionado a CoffeeScript não ter suporte a &lt;em&gt;variable shadowing&lt;/em&gt;.&lt;/li&gt;&lt;li&gt;O código foi inteiramente portado para o &lt;em&gt;strict mode&lt;/em&gt; sem problemas como atribuição em propriedades &lt;em&gt;read-only&lt;/em&gt;.&lt;/li&gt;&lt;li&gt;As primeiras conversões em massa foram feitas nos testes automáticos.&lt;/li&gt;&lt;li&gt;Uma boa configuração do &lt;a href=&quot;https://www.youtube.com/watch?v=muvU1DYrY0w&quot;&gt;itest&lt;/a&gt; permitia checar rapidamente quais modificações eram a origem dos problemas.&lt;/li&gt;&lt;li&gt;Foi importante ter rigor na escrita das traduções de código, cobrindo todos os &lt;em&gt;corner cases&lt;/em&gt; e explicitando quais casos eram ignorados.&lt;/li&gt;&lt;/ul&gt;&lt;h2&gt;A última parte&lt;/h2&gt;&lt;ul&gt;&lt;li&gt;Nas últimas semanas as ferramentas eram capazes de converter entre 100 e 200 arquivos numa única passagem.&lt;/li&gt;&lt;li&gt;Um dos truques para iterar rapidamente é rodar o &lt;em&gt;typecheck&lt;/em&gt; incremental (&lt;code&gt;tsc --noEmit --watch&lt;/code&gt;).&lt;/li&gt;&lt;li&gt;O número de arquivos em CoffeeScript era mantido atualizado num quadro branco.&lt;/li&gt;&lt;li&gt;Apenas dois bugs entraram em produção.&lt;/li&gt;&lt;li&gt;Ao time mais resistente à mudança foi prometido que erros ficariam a cargo dos engenheiros envolvidos na migração.&lt;/li&gt;&lt;li&gt;Ao se admitir como produto um código TypeScript não-idiomático, foram gastos 2 meses de trabalho de três engenheiros (cerca de 19 engenheiros-semana).&lt;/li&gt;&lt;li&gt;&amp;quot;Nós devemos economizar nosso capital político e organizacional com trabalhos que não podemos automatizar para todos&amp;quot;; assim, a conversão manual foi descartada.&lt;/li&gt;&lt;li&gt;Atualmente, o time da Dropbox mantém 2kk linhas de TypeScript.&lt;/li&gt;&lt;/ul&gt;</content:encoded></item><item><title><![CDATA[Uma sugestão para simular um e-paper]]></title><description><![CDATA[É necessário o alinhamento de software e hardware para ficar perfeito, mas utilizar apenas um deles já confere uma boa aproximação do efeito…]]></description><link>/2020-05-23/uma-sugestao-para-simular-um-e-paper/</link><guid isPermaLink="false">/2020-05-23/uma-sugestao-para-simular-um-e-paper/</guid><pubDate>Sat, 23 May 2020 01:39:51 GMT</pubDate><content:encoded>&lt;p&gt;É necessário o alinhamento de software e hardware para ficar perfeito, mas utilizar apenas um deles já confere uma boa aproximação do efeito desejado.&lt;/p&gt;&lt;h2&gt;Software&lt;/h2&gt;&lt;p&gt;O fundo deve ser um tom de cinza claro como &lt;code&gt;rgb(236, 236, 236)&lt;/code&gt; ou mais claro, enquanto a cor do texto deve ser 25% a 30% mais clara que o preto.&lt;/p&gt;&lt;p&gt;A fonte de corpo de texto deve ter uma aparência suave. Há uma preferência para fontes serifadas porém acredito que isto não deveria ser uma regra geral. A tipografia deve acompanhar o significado que o texto transmite onde é possível ser determinado e definida pelo leitor/usuário quando não é inferível o tom de voz do texto. Particularmente acredito que fontes serifadas são ótimas para textos de estrutura mais linear -- como ficções e artigos com poucos recursos gráficos. Uma fonte mono-espaçada seria aconselhável quando o texto deve ser &lt;em&gt;escaneado&lt;/em&gt; pelo leitor, e.g., tabelas de dados e índices.&lt;/p&gt;&lt;p&gt;O espaçamento de linha ideal está entre 125% e 150% do tamanho da fonte. Em geral, uma margem mínima de 10pt em todas as direções de qualquer bloco de texto é suficiente para demarcar as divisões semânticas do texto.&lt;/p&gt;&lt;h2&gt;Hardware&lt;/h2&gt;&lt;p&gt;Uma película protetora anti-reflexiva combinada com a variação de brilho entre 45% para interiores e 75% para iluminação exterior.&lt;/p&gt;</content:encoded></item><item><title><![CDATA[Dark mode não-adaptativo: uma escolha puramente estética]]></title><description><![CDATA[Advoga-se por aí que todas as interfaces digitais devem ao menos prover um modo escuro, o famigerado  dark mode . Não sei ao certo a origem…]]></description><link>/2020-05-23/dark-mode-nao-adaptativo-uma-escolha-puramente-estetica/</link><guid isPermaLink="false">/2020-05-23/dark-mode-nao-adaptativo-uma-escolha-puramente-estetica/</guid><pubDate>Fri, 22 May 2020 23:55:25 GMT</pubDate><content:encoded>&lt;p&gt;Advoga-se por aí que todas as interfaces digitais devem ao menos prover um modo escuro, o famigerado &lt;em&gt;dark mode&lt;/em&gt;. Não sei ao certo a origem dessa &amp;quot;necessidade&amp;quot; pós-2018, mas não é difícil conjecturar que deva ter surgido no meio do desenvolvimento de software. A justificativa? Descanso visual por uso prolongado de displays.&lt;/p&gt;&lt;p&gt;Acredito que a necessidade real seja outra; me baseio na escolha que muitos conhecidos fotossensíveis têm por trabalhar em ambientes escuros apesar de usar displays com nível de brilho alto, o que, além de destruir o ciclo circadiano, causa cansaço da musculatura complexa dos olhos.&lt;/p&gt;&lt;p&gt;O descanso deve ser para outro órgão: o cérebro do programador, que deve interpretar sintaticamente blocos de texto diferenciando palavras-chaves, identificadores, delimitadores, literais. O modo escuro seria um acessório ao realce de sintaxe, uma vez que o texto colorido é melhor diferenciado contra um fundo preto ou cinza escuro.&lt;/p&gt;&lt;p&gt;Para textos lineares, como os de literatura ou com poucos elementos gráficos e tópicos, tons de sépia e tons simulando o e-ink são muito mais adequados para relaxamento visual. Desta forma, o modo do tema deveria ser adaptativo ao conteúdo, mas ainda prefere-se que ele seja definido pelo contexto, como as cores do sistema ou o modo noturno.&lt;/p&gt;</content:encoded></item></channel></rss>