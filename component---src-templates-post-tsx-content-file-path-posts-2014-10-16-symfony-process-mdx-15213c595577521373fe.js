"use strict";(self.webpackChunk_tassoevan_tassoevan_github_io=self.webpackChunk_tassoevan_tassoevan_github_io||[]).push([[863],{3881:function(e,a,o){o.r(a),o.d(a,{default:function(){return i}});var n=o(8453),t=o(6540);function r(e){const a=Object.assign({p:"p",a:"a",em:"em",strong:"strong",code:"code",ol:"ol",li:"li",h1:"h1",pre:"pre",h2:"h2",h3:"h3"},(0,n.R)(),e.components);return t.createElement(t.Fragment,null,t.createElement(a.p,null,"Como ",t.createElement(a.a,{href:"http://stackoverflow.com/questions/13600598/convert-pdf-to-jpg-image-with-php"},"converter um PDF em imagens PNG ou JPEG"),", ",t.createElement(a.em,null,"usando PHP"),"? Como ",t.createElement(a.a,{href:"http://stackoverflow.com/questions/1571134/how-can-i-convert-an-avi-file-to-flv-format-with-php"},"converter arquivos de vídeo enviados via upload em formatos para a web"),", como WebM ou FLV, ",t.createElement(a.em,null,"usando PHP"),"? Como realizar uma tarefa administrativa no servidor, ",t.createElement(a.em,null,"usando PHP"),"?"),"\n",t.createElement(a.p,null,"Muitas vezes nos fazemos essas perguntas e passamos por algumas decepções ao procurar soluções. A primeira é descobrir que nem sempre podemos resolver usando única e exclusivamente a linguagem e/ou tecnologia que usamos em nossos projetos: PHP não foi construída para executar tarefas longas e que demandam alto processamento, como converter formatos de imagem, áudio e vídeo. Até podemos considerar o uso de extensões (como a ",t.createElement(a.a,{href:"http://php.net/manual/en/book.imagick.php"},"ImageMagick"),"), mas geralmente o modo rápido de conseguir o que se quer é através de ",t.createElement(a.strong,null,"programas externos"),", como ",t.createElement(a.code,null,"avconv")," e ",t.createElement(a.code,null,"convert"),"."),"\n",t.createElement(a.p,null,"A principal dificuldade esperada ao realizar a integração entre scripts PHP e programas externos é a perda de compatibilidade nas diversas plataformas em que PHP é executável. A maioria dos exemplos de uso das funções ",t.createElement(a.code,null,"exec()"),", ",t.createElement(a.code,null,"shell_exec()")," e ",t.createElement(a.code,null,"passthru()")," utiliza programas do ecossistema Unix e, ao menos no Brasil, o número de desenvolvedores PHP que rodam Windows em suas estações de trabalho é grande. Para eles, usar programas externos é adicionar ao seu código algo que só poderá ser testado em servidores de teste ou desenvolvimento — uma realidade que vem mudando, a passos de formiga, com a adoção de ferramentas como ",t.createElement(a.a,{href:"http://www.vagrantup.com/"},"Vagrant")," e ",t.createElement(a.a,{href:"http://www.docker.com/"},"Docker"),"."),"\n",t.createElement(a.p,null,"Então é simples usar programas externos? Não. Todo programa é executado como um novo ",t.createElement(a.strong,null,"processo")," do sistema, chamado pelo ",t.createElement(a.strong,null,"shell")," através de uma ",t.createElement(a.strong,null,"linha de comando"),". E neste contexto, existem algumas coisas a se considerar:"),"\n",t.createElement(a.ol,null,"\n",t.createElement(a.li,null,"Deve ser garantido que nenhum número abusivo de processos seja executado;"),"\n",t.createElement(a.li,null,"Deve ser garantido que ",t.createElement(a.a,{href:"http://en.wikipedia.org/wiki/Code_injection#Shell_injection"},"nenhum dado enviado execute código arbitrário"),";"),"\n",t.createElement(a.li,null,"Todo processo possui uma ",t.createElement(a.a,{href:"http://en.wikipedia.org/wiki/Standard_streams#Standard_input_.28stdin.29"},"stream de entrada de dados"),", uma ",t.createElement(a.a,{href:"http://en.wikipedia.org/wiki/Standard_streams#Standard_output_.28stdout.29"},"stream de saída normal")," e uma ",t.createElement(a.a,{href:"http://en.wikipedia.org/wiki/Standard_streams#Standard_error_.28stderr.29"},"stream de saída de erros"),";"),"\n",t.createElement(a.li,null,"Alguns processos exigem interação do usuário através da stream de entrada;"),"\n",t.createElement(a.li,null,"Alguns processos são longos;"),"\n",t.createElement(a.li,null,"Alguns processos escrevem dados em formatos complexos nas streams de saída;"),"\n",t.createElement(a.li,null,"Processos retornam um ",t.createElement(a.a,{href:"http://en.wikipedia.org/wiki/Exit_status"},"código de status de fim de execução")," que indica erros ocorridos durante a execução."),"\n"),"\n",t.createElement(a.p,null,"Vamos ver que opções as funções padrão do PHP nos fornecem para trabalhar com processos:"),"\n",t.createElement(a.h1,null,t.createElement(a.a,{href:"http://php.net/manual/en/function.shell-exec.php"},t.createElement(a.code,null,"string shell_exec(string $cmd)"))," ou ",t.createElement(a.a,{href:"http://php.net/manual/en/language.operators.execution.php"},t.createElement(a.code,null,"`$cmd`"))),"\n",t.createElement(a.p,null,"É a função ideal para processos invocados com uma linha de comando simples e que escrevem apenas uma linha de texto na stream de saída."),"\n",t.createElement(a.ol,null,"\n",t.createElement(a.li,null,"Somente um processo pode ser executado por vez, a menos que se utilizem mecanismos de execução paralela presentes no shell (e.g. ",t.createElement(a.code,null,"start convert doc.pdf images.jpg")," em Windows)."),"\n",t.createElement(a.li,null,"Você depende de ",t.createElement(a.code,null,"escapeshellarg($arg)")," para escapar argumentos vindos da entrada de usuário. Usar ou não usar é por sua conta e risco. Para o operador de execução (",t.createElement(a.code,null,"` `"),") é impossível passar dados de usuário, como se a definição da linha de comando do processo fosse constante."),"\n",t.createElement(a.li,null,"Tudo o que foi escrito na stream de saída é retornado pela função. Em caso de erro, entretanto, é retornado o valor ",t.createElement(a.code,null,"NULL"),", mesmo que dados tenham sido escritos."),"\n",t.createElement(a.li,null,"Não permite escrever dados na stream de entrada."),"\n",t.createElement(a.li,null,"Você não pode definir um tempo máximo para a execução do processo, embora fique limitado pelo limite de tempo de execução do próprio script PHP."),"\n",t.createElement(a.li,null,"Você precisa parsear toda a stream de saída obtida através do retorno da função/expressão."),"\n",t.createElement(a.li,null,"Você não obtém o código de status. Se ele for zero, a função retorna o conteúdo da stream de saída; caso contrário, ",t.createElement(a.code,null,"NULL")," é retornado."),"\n"),"\n",t.createElement(a.h1,null,t.createElement(a.a,{href:"http://php.net/manual/en/function.exec.php"},t.createElement(a.code,null,"string exec(string $command[, array &$output[, int &$return_var]])"))),"\n",t.createElement(a.p,null,"Esta função adiciona um grau maior de controle sob o que é escrito na stream de saída e sobre os códigos de status."),"\n",t.createElement(a.ol,null,"\n",t.createElement(a.li,null,"Somente um processo pode ser executado por vez, a menos que se utilizem mecanismos de execução paralela presentes no shell."),"\n",t.createElement(a.li,null,"Você depende de ",t.createElement(a.code,null,"escapeshellarg($arg)")," para escapar argumentos vindos da entrada de usuário. Usar ou não usar é por sua conta e risco."),"\n",t.createElement(a.li,null,"Você pode ter acesso ao que foi escrito na stream de saída através do array ",t.createElement(a.code,null,"$output")," ou apenas da última linha escrita através do retorno da função."),"\n",t.createElement(a.li,null,"Não permite escrever dados na stream de entrada."),"\n",t.createElement(a.li,null,"Você não pode definir um tempo máximo para a execução do processo, embora fique limitado pelo limite de tempo de execução do próprio script PHP."),"\n",t.createElement(a.li,null,"Você precisa parsear toda a stream de saída obtida através de ",t.createElement(a.code,null,"$output"),"."),"\n",t.createElement(a.li,null,"Você obtém o código de status através de ",t.createElement(a.code,null,"$return_var"),"."),"\n"),"\n",t.createElement(a.h1,null,t.createElement(a.a,{href:"http://php.net/manual/en/function.passthru.php"},t.createElement(a.code,null,"void passthru(string $command[, int &$return_var])"))),"\n",t.createElement(a.p,null,"O uso mais comum desta função é quando o script PHP funciona como um simples proxy para um programa externo, como um gerador de imagens ou compilador."),"\n",t.createElement(a.ol,null,"\n",t.createElement(a.li,null,"Somente um processo pode ser executado por vez, a menos que se utilizem mecanismos de execução paralela presentes no shell."),"\n",t.createElement(a.li,null,"Você depende de ",t.createElement(a.code,null,"escapeshellarg($arg)")," para escapar argumentos vindos da entrada de usuário. Usar ou não usar é por sua conta e risco."),"\n",t.createElement(a.li,null,"A stream de saída do processo é redirecionada para a stream de saída do script PHP. Se você quiser capturar a saída, vai ter que utilizar mecanismos de ",t.createElement(a.em,null,"output buffering")," (",t.createElement(a.code,null,"ob_start()"),")."),"\n",t.createElement(a.li,null,"Não permite escrever dados na stream de entrada."),"\n",t.createElement(a.li,null,"Você não pode definir um tempo máximo para a execução do processo, embora fique limitado pelo limite de tempo de execução do próprio script PHP."),"\n",t.createElement(a.li,null,"Você precisa parsear toda a stream de saída obtida através de ",t.createElement(a.em,null,"output buffering"),"."),"\n",t.createElement(a.li,null,"Você obtém o código de status através de ",t.createElement(a.code,null,"$return_var"),"."),"\n"),"\n",t.createElement(a.h1,null,t.createElement(a.a,{href:"php.net/manual/en/function.proc-open.php"},t.createElement(a.code,null,"resource proc_open(string $cmd, array $descriptorspec, array &$pipes[, string $cwd[, array $env[, array $other_options]]])"))),"\n",t.createElement(a.p,null,"E aqui temos o maior controle possível de processos (inclusive do diretório de trabalho do processo, via ",t.createElement(a.code,null,"$cwd"),") através de scripts PHP."),"\n",t.createElement(a.ol,null,"\n",t.createElement(a.li,null,"Esta função é não-bloqueante, de modo que você pode iniciar quantos processos julgar adequado. Vale o bom senso para garantir que uma quantidade não-abusiva de processos sejam rodados paralelamente."),"\n",t.createElement(a.li,null,"Você depende de ",t.createElement(a.code,null,"escapeshellarg($arg)")," para escapar argumentos vindos da entrada de usuário. Usar ou não usar é por sua conta e risco."),"\n",t.createElement(a.li,null,"Você tem acesso a ",t.createElement(a.em,null,"stdin"),", ",t.createElement(a.em,null,"stdout")," e ",t.createElement(a.em,null,"stderr")," através do array ",t.createElement(a.code,null,"$pipes"),", como se fossem ponteiros de arquivo tradicionais."),"\n",t.createElement(a.li,null,t.createElement(a.em,null,"stdin")," é uma stream de escrita, onde você pode escrever usando funções simples como ",t.createElement(a.code,null,"fwrite()"),"."),"\n",t.createElement(a.li,null,"O controle de ",t.createElement(a.em,null,"timeout")," dos processos pode ser implementado, já que o processo roda paralelamente ao script."),"\n",t.createElement(a.li,null,"A leitura dos dados escritos em ",t.createElement(a.em,null,"stdout")," e ",t.createElement(a.em,null,"stderr")," não difere da leitura de um arquivo; assim, as mesmas técnicas empregadas para parsear um arquivo podem ser aplicadas, seja de forma integral (ler toda a stream e interpretar o formato), seja de forma contínua (ler a stream linha a linha e interpretar durante a execução)."),"\n",t.createElement(a.li,null,"Você pode ter o código de status a partir do retorno de ",t.createElement(a.code,null,"proc_close($process)"),"."),"\n"),"\n",t.createElement(a.h1,null,"Tudo é complicado"),"\n",t.createElement(a.p,null,"Pelo que se percebe, a complexidade para se executar certos processos via PHP é semelhante à própria complexidade do processo, i.e., um processo que exige interação com todas as streams, ",t.createElement(a.em,null,"timeout")," e controle do código de status vai demandar o uso de uma função muito complexa. ",t.createElement(a.a,{href:"http://php.net/manual/en/function.proc-open.php#example-3774"},"Veja você mesmo"),":"),"\n",t.createElement(a.pre,null,t.createElement(a.code,{className:"language-php"},'<?php\n$descriptorspec = array(\n   0 => array("pipe", "r"),  // stdin is a pipe that the child will read from\n   1 => array("pipe", "w"),  // stdout is a pipe that the child will write to\n   2 => array("file", "/tmp/error-output.txt", "a") // stderr is a file to write to\n);\n\n$cwd = \'/tmp\';\n$env = array(\'some_option\' => \'aeiou\');\n\n$process = proc_open(\'php\', $descriptorspec, $pipes, $cwd, $env);\n\nif (is_resource($process)) {\n    // $pipes now looks like this:\n    // 0 => writeable handle connected to child stdin\n    // 1 => readable handle connected to child stdout\n    // Any error output will be appended to /tmp/error-output.txt\n\n    fwrite($pipes[0], \'<?php print_r($_ENV); ?>\');\n    fclose($pipes[0]);\n\n    echo stream_get_contents($pipes[1]);\n    fclose($pipes[1]);\n\n    // It is important that you close any pipes before calling\n    // proc_close in order to avoid a deadlock\n    $return_value = proc_close($process);\n\n    echo "command returned $return_value\\n";\n}\n')),"\n",t.createElement(a.p,null,"Nesse exemplo, abrimos o processo ",t.createElement(a.code,null,"php"),", escrevemos na stream de entrada o código ",t.createElement(a.code,null,"<?php print_r($_ENV); ?>")," e lemos o resultado da execução na stream de saída do processo. Nenhum mecanismo de ",t.createElement(a.em,null,"timeout")," é implementado, bem como nenhum controle de erros é realizado através da stream de erros e do código de status, e mesmo assim temos um código assustador para programadores novatos."),"\n",t.createElement(a.h2,null,"Symfony Process ao resgate"),"\n",t.createElement(a.p,null,"Streams, código de status, ",t.createElement(a.em,null,"timeout"),", diretório de trabalho, argumentos escapados... Muitos são os componentes e detalhes presentes na execução de um processo. Para nossa sorte, o componente ",t.createElement(a.a,{href:"http://symfony.com/doc/current/components/process.html"},"Symfony Process")," provê um mecanismo simples para execução e controle de processos (e ao contrário do que muitos pensam ",t.createElement(a.strong,null,"não é necessário estar utilizando o framework Symfony para usufruir deste componente"),"). Vamos recriar o exemplo supracitado para demonstrar isso."),"\n",t.createElement(a.p,null,"Primeiramente, você pode baixar as classes do Symfony Process de modo tradicional, mas isso é desaconselhado; prefira fazer o controle deste e de demais códigos de terceiros através do ",t.createElement(a.a,{href:"https://getcomposer.org"},"Composer"),", um gerenciador de dependências para PHP que se tornou praticamente o padrão da indústria. Caso você ainda não esteja utilizando no seu projeto, execute no terminal"),"\n",t.createElement(a.pre,null,t.createElement(a.code,{className:"language-sh"},"$ composer init\n")),"\n",t.createElement(a.p,null,"E forneça informações básicas do seu projeto. Assim que o arquivo ",t.createElement(a.code,null,"composer.json")," estiver disponível, execute"),"\n",t.createElement(a.pre,null,t.createElement(a.code,{className:"language-sh"},"$ composer require symfony/process\n")),"\n",t.createElement(a.p,null,"Para adicionar ao seu projeto a última versão do componente Symfony Process. Todo o código fica disponível no diretório ",t.createElement(a.code,null,"vendor/symfony/process")," e o arquivo ",t.createElement(a.code,null,"composer.lock")," é criado para registrar qual a versão utilizada."),"\n",t.createElement(a.p,null,"Com a library em mãos, vamos recriar o exemplo passo-a-passo. Escreva, num arquivo chamado ",t.createElement(a.code,null,"exemplo.php"),", as seguintes linhas:"),"\n",t.createElement(a.pre,null,t.createElement(a.code,{className:"language-php"},"<?php\nrequire __DIR__.'/vendor/autoload.php';\n\nuse Symfony\\Component\\Process\\Process;\n")),"\n",t.createElement(a.p,null,"A primeira linha vai adicionar o autoloader do Composer, tornando acessíveis todas as classes do Symfony Process. A linha seguinte permite que a classe ",t.createElement(a.code,null,"Symfony\\Component\\Process\\Process")," possa ser chamada apenas de ",t.createElement(a.code,null,"Process")," no script. Ainda no mesmo arquivo, escreva:"),"\n",t.createElement(a.pre,null,t.createElement(a.code,{className:"language-php"},"$process = new Process('php');\n")),"\n",t.createElement(a.p,null,"Essa linha não executa o processo ",t.createElement(a.code,null,"php")," de imediato, apenas prepara uma instância da classe ",t.createElement(a.code,null,"Process")," que representa um processo antes, durante, e após sua execução."),"\n",t.createElement(a.pre,null,t.createElement(a.code,{className:"language-php"},"$process->setInput('<?php print_r($_ENV); ?>');\n")),"\n",t.createElement(a.p,null,"Aqui foi definido qual conteúdo será escrito em ",t.createElement(a.em,null,"stdin")," que o processo seja executado (esse método lança ",t.createElement(a.code,null,"RuntimeException")," se é executado depois que o processo é executado)."),"\n",t.createElement(a.pre,null,t.createElement(a.code,{className:"language-php"},"$process->run(function ($type, $buffer) {\n    if (Process::ERR === $type) {\n        echo 'ERR > '.$buffer;\n    } else {\n        echo 'OUT > '.$buffer;\n    }\n});\n")),"\n",t.createElement(a.p,null,"Aqui o processo é executado de fato, de forma síncrona (para executar o processo de forma asíncrona, ",t.createElement(a.code,null,"$process->start()")," deve ser invocado no lugar de ",t.createElement(a.code,null,"$process->run()"),"), mas com um adendo: toda saída gerada pelo processo, em ",t.createElement(a.em,null,"stdout")," e ",t.createElement(a.em,null,"stderr"),", é passada imediatamente para o callable passado como parâmetro do método ",t.createElement(a.code,null,"run()")," (neste caso, é uma closure). O callable deve aceitar dois parâmetros: ",t.createElement(a.code,null,"$type"),", que indica se a saída foi escrita em ",t.createElement(a.em,null,"stdout")," ou ",t.createElement(a.em,null,"stderr"),"; ",t.createElement(a.code,null,"$buffer"),", que contém o texto escrito."),"\n",t.createElement(a.p,null,"E... Isso é tudo. Você não precisa fechar o processo, muito menos pará-lo. Segue o exemplo completo:"),"\n",t.createElement(a.pre,null,t.createElement(a.code,{className:"language-php"},"<?php\nrequire __DIR__.'/vendor/autoload.php';\n\nuse Symfony\\Component\\Process\\Process;\n\n$process = new Process('php');\n$process->setInput('<?php print_r($_ENV); ?>');\n$process->run(function ($type, $buffer) {\n    if (Process::ERR === $type) {\n        echo 'ERR > '.$buffer;\n    } else {\n        echo 'OUT > '.$buffer;\n    }\n});\n\n")),"\n",t.createElement(a.h3,null,"Agora vá!"),"\n",t.createElement(a.p,null,"Espero que este artigo tenha instigado o leitor investir um pouco de atenção ao componente Symfony Process. As possibilidades com ele são interessantes, principalmente se o seu desejo for de adicionar poder de fogo à sua aplicação web. Em breve devo demonstrar mais casos de uso, como invocação de ",t.createElement(a.code,null,"convert"),", ",t.createElement(a.code,null,"avconv")," e ",t.createElement(a.code,null,"rsync"),". Até lá!"))}var s=function(e){void 0===e&&(e={});const{wrapper:a}=Object.assign({},(0,n.R)(),e.components);return a?t.createElement(a,e,t.createElement(r,e)):r(e)},l=o(4387),c=o(6008),m=o(9031),d=o(4615);function u(e){let{pageContext:a,data:o,children:n}=e;const{frontmatter:{title:r,date:s},slug:u,next:i}=a,{excerpt:p,timeToRead:E}=o.mdx;return t.createElement(t.Fragment,null,t.createElement(l.A,{title:r,description:p}),t.createElement(c.A,null,t.createElement(m.A,null),t.createElement(d.A,{slug:u,title:r,date:new Date(Date.parse(s)),timeToRead:Math.ceil(E),next:i},n)))}function i(e){return t.createElement(u,e,t.createElement(s,e))}},9031:function(e,a,o){var n=o(6540),t=o(7581),r=o(8864),s=o(4017);const l=t.default.nav.withConfig({displayName:"NavBar__StyledNavBar",componentId:"sc-yc90xv-0"})(["h1{font-size:1em;font-weight:normal;margin:0;}"]);a.A=function(){const{title:e,description:a}=(0,r.Q)();return n.createElement(l,null,n.createElement("h1",null,n.createElement(s.A,{href:"/",title:a},e)))}},8453:function(e,a,o){o.d(a,{R:function(){return s}});var n=o(6540);const t={},r=n.createContext(t);function s(e){const a=n.useContext(r);return n.useMemo((function(){return"function"==typeof e?e(a):{...a,...e}}),[a,e])}}}]);
//# sourceMappingURL=component---src-templates-post-tsx-content-file-path-posts-2014-10-16-symfony-process-mdx-15213c595577521373fe.js.map